"""Routines for working with the ZTF discrete field grid"""

import numpy as np
import pandas as pd
from utils import *
import astropy.coordinates as coords
import astropy.units as u
from astropy.time import Time

class Fields:
    """Class for accessing field grid."""
    # TODO: consider using some of PTFFields.py code 
    def __init__(self,dbname='test_fields'):
        self._load_fields(dbname=dbname)
        self.loc = P48_loc
        
    def _load_fields(self, dbname='test_fields'):
        """Loads a field grid from ../data/{dbname}.db.  
        Expects fieldid, ra (deg), dec (deg) columns"""
        df = df_read_from_sqlite(dbname, index_col = 'fieldid')
        self.fields = df
        # TODO: consider dropping fields below dec < -30
        # TODO: load last observed time per filter & program
        # TODO: load total observations per filter & program

    def field_coords(self, cuts = None):
        """Generate an astropy SkyCoord object for current fields"""
        if cuts is None:
            fields = self.fields
        else:
            fields = self.fields[cuts]
        return coords.SkyCoord(fields['ra'], 
            fields['dec'], frame='icrs', unit='deg')

    def alt_az(self, time, cuts = None):
        """return Altitude & Azimuth by field at a given time"""

        if cuts is None:
            index = self.fields.index
        else:
            index = self.fields[cuts].index

        fieldsAltAz = self.field_coords(cuts=cuts).transform_to(
            coords.AltAz(obstime=time, location=self.loc))
        return pd.DataFrame({'alt':fieldsAltAz.alt, 'az':fieldsAltAz.az},
            index = index)

    def overhead_time(self, current_fieldid, time, cuts = None):
        """Calculate overhead time in seconds from current position.
        
        cuts is a boolean series indexed by fieldid, as generated by 
        select_fields """
        # TODO: think about partitioning this. dome slew is the only 
        # time-dependent value
        # TODO: figure out appropriate treatment of dome at zenith
        # TODO: fails if current_fieldid is not in cuts.  Better to pass in
        # telescope status? time, alt, az, dome?  Might not be a current
        # field_id after bad weather, etc.

        if cuts is None:
            fields = self.fields
        else:
            fields = self.fields[cuts] 

        df = fields.join(self.alt_az(time, cuts = cuts))

        row = df.loc[current_fieldid]

        slews_by_axis = {'readout':READOUT_TIME}
        for axis in ['ha', 'dec', 'dome']:
            coord = P48_slew_pars[axis]['coord']
            dangle = np.abs(df[coord] - row[coord])
            angle = np.where(dangle < (360. - dangle), dangle, 360. - dangle)
            slews_by_axis[axis] = slew_time(axis, angle*u.deg)

        dfslews = pd.DataFrame(slews_by_axis,index=df.index)
        
        dfmax = dfslews.max(axis=1)
        dfmax = pd.DataFrame(dfmax)
        dfmax.columns = ['overhead_time']
    
        return dfmax

    def select_fields(self, 
    	ra_range = None, dec_range = None,
    	l_range = None, b_range = None, 
        ecliptic_lon_range = None, ecliptic_lat_range = None, 
        gridid = None): 
	"""Select a subset of fields based on their sky positions.

        Each _range keyword takes a list [min,max].
        gridid is a scalar"""
        # TODO: allow searches by past exposures (total number, last observed)
        # (by filter and program)


	# start with a boolean True series:
	cuts = (self.fields['ra'] == self.fields['ra'])

	range_keys = ['ra', 'dec', 'l', 'b', 'ecliptic_lon', 'ecliptic_lat']

	for i, arg in enumerate([ra_range, dec_range, l_range, b_range,
            ecliptic_lon_range, ecliptic_lat_range]):
	    if arg is not None:
		cuts = cuts & (self.fields[range_keys[i]] >= arg[0]) & \
		    (self.fields[range_keys[i]] <= arg[1])

	scalar_keys = ['gridid']

	for i, arg in enumerate([gridid]):
	    if arg is not None:
		cuts = cuts & (self.fields[scalar_keys[i]] == arg) 

	return cuts
	     
		

        

def generate_test_field_grid(filename='../data/ZTF_fields.txt', 
    dbname='test_fields'):
    """Convert Eran's field grid to sqlite"""

    df = pd.read_table(filename,delimiter='\s+',skiprows=1,
            names = ['fieldid','ra','dec','extinction_b-v',
            'l','b',
            'ecliptic_lon','ecliptic_lat'],index_col=0)

    # insert label for offset grids
    grid = pd.Series(df.index >=
            1000,index=df.index,name='gridid',dtype=np.int8)

    df = df.join(grid)

    df_write_to_sqlite(df[['ra','dec','l','b','ecliptic_lon','ecliptic_lat',
        'gridid']], dbname, index_label='fieldid')
